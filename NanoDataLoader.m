%% Nanoindentation Data Loader
% Written by Robert J Scales

function NanoDataLoader(debugON,PlotAesthetics,DefaultDlg,ImageFormatType)
%% Basic Set-up
% The comments for what the below does can be found pretty much in
% NanoDataCreater!

clc;
dlg_title = 'NanoindentationDataLoader';
fprintf('%s: Started!\n\n',dlg_title);
NanoCreaterLoaderClearer(false,false);
LOC_init = cd;

% This loads the ".mat" files produced by NanoDataCreater which the user
% wishes to plot on the same figure.
[FileStuctures,fileNameList,~] = LoadingFilesFunc(debugON);

% The below chooses how the data will be presented in the figures.
[FormatAnswer] = FormattingChoosing(dlg_title,DefaultDlg);

%% Plotting

% This function plots all of the figures that you want to plot based on the
% structure FileStuctures generated by LoadingFilesFunc above.
NanoPlotter(FileStuctures,PlotAesthetics,FormatAnswer);

%% Meaning the data across a depth range
% This section will generate an Excel table that contains the meaned value
% and its associaed error based on an indent depth range given by the user.

cd(LOC_init);
ToMeanOrNotToMean = questdlg('Find a mean value within a range?',dlg_title,'Yes','No','No');
switch ToMeanOrNotToMean
    case 'Yes'
        % This is the function that does all of the work.
        NanoMeaner(FileStuctures,figHandles,DataTypeList,PlotDataTypes,LOC_init,debugON);
    otherwise
        disp('You have decided not to find the mean value within a range...');
end

%% Saving Results

% Loading mode is true as we using the Loader function.
LoadingMode = true;
cd(LOC_init);
% The output data is mainly useful for NanoDataCreater but not for this.
[~,~,~,~] = NanoDataSave(ImageFormatType,LoadingMode,LOC_init,fileNameList);


fprintf('NanoDataLoader: Complete!\n\n');

end











    
%% Functions

function [FileStuctures,fileNameList,LOC_load] = LoadingFilesFunc(debugON)    
    % This allows to get the file name and location information for
    % multiple files.
    [file,path] = uigetfile('*.mat','Select nanoindentation "mat" files made by "NanoDataCreater" to plot (must all be in one folder):','MultiSelect','on');

    % If no file is selected then the output of the above is an empty
    % double.
    if isa(file,'double') == true
        errordlg('No files selected! Code will terminate!')
        return
    end
    
    % The loading path is specified by where the files are loaded from.
    LOC_load = path;
    
    % If one file is chosen its file type will be char and not cell, hence
    % this makes it into a 1x1 cell if true.
    if isa(file,'char') == true
        file = cellstr(file);
    end
    
    % This calculates the number of samples the user has chosen based on
    % the number of files chosen.
    NumberOfFiles = length(file);

    if debugON == true
        fprintf('Loading files from "%s"...\n',LOC_load);
        fprintf('Number of files detected = %d\n',NumberOfFiles);
    end
    
    % This prepares a string array to be filled in with the full filenames
    % and the name the user wished to label the data with.
    fileNameList = strings(NumberOfFiles,2);
    FileStuctures = cell(NumberOfFiles,1);
    
    % This fills in fileNameList
    for i =1:NumberOfFiles
        filename = fullfile(path,file{i});
        fileNameList(i,1) = file{i};
        fileNameList(i,2) = filename;
        FileStucturesProto = load(filename,'-mat');
        FileStuctures{i} = FileStucturesProto.dataToSave;
        if debugON == true
            fprintf('Loaded file named "%s"\n',file{i});
        end
    end
end

% This function is pretty self-explanatory
function [FormatAnswer] = FormattingChoosing(dlg_title,DefaultDlg)
    % This is how the data will be shown on the graph.
    FormatAnswer = questdlg('How do you want to present the data?',dlg_title,'Line + Error Region','Line + Error Bars','Line',DefaultDlg.FormatAnswer);

    switch FormatAnswer
        case 'Line'
            disp('No error bars will be shown on the graph');
        case ''
            errordlg('Exit button was pressed! Code will terminate!')
            return
    end
end






