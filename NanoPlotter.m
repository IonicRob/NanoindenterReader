%% Nanoindentation Data Loader
% Written by Robert J Scales

function NanoPlotter(debugON,PlotAesthetics,DefaultDlg,ChooseSaveType,DfltImgFmtType)
%% Basic Set-up
% The comments for what the below does can be found pretty much in
% NanoDataCreater!

clc;
dlg_title = 'NanoPlotter';
fprintf('%s: Started!\n\n',dlg_title);
cd_init = cd;

if ChooseSaveType == true
    % This function sets the figure image saving file type.
    ImageFormatType = changeFigureSaveType;
else
    % This occurs when choosing the save type isn't explicit and so chooses
    % the default image format type (in NanoMainCode).
    ImageFormatType = DfltImgFmtType;
    clear DfltImgFmtType
    fprintf('Default saving format of "%s" has been chosen!\n',ImageFormatType);
end

% This loads the ".mat" files produced by NanoDataCreater which the user
% wishes to plot on the same figure.
[FileStuctures,~,cd_load] = LoadingFilesFunc(debugON,'on');

% The below uses the function checkStructuresCompat to see if the data
% analysis done on the files is the same. See function below for further
% details.
passTF = checkStructuresCompat(debugON,FileStuctures);
if passTF == false
    % This is done as otherwise the return in the function stops the
    % function but not this function!
    return
end


% The below chooses how the data will be presented in the figures.
% This is how the data will be shown on the graph.
FormatAnswer = questdlg('How do you want to present the data?',dlg_title,'Line + Error Region','Line + Error Bars','Line',DefaultDlg.FormatAnswer);
if strcmp(FormatAnswer,'') == true
    DLG = errordlg('Exit button was pressed! Code will terminate!');
    waitfor(DLG);
    return
end

%% Plotting

% This function plots all of the figures that you want to plot based on the
% structure FileStuctures generated by LoadingFilesFunc above.
[DataTypeList,PlotDataTypes,figHandles] = NanoPlotter_main(debugON,FileStuctures,PlotAesthetics,FormatAnswer);

if debugON == true
    disp('Post figure handles are:');
    disp(figHandles);
end

%% Meaning the data across a depth range
% This section will generate an Excel table that contains the meaned value
% and its associaed error based on an indent depth range given by the user.

cd(cd_init);
ToMeanOrNotToMean = questdlg('Find a mean value within a range?',dlg_title,'Yes','No','No');
switch ToMeanOrNotToMean
    case 'Yes'
        % This is the function that does all of the work in meaning the
        % data within a range.
        DataIDName = NanoMeaner(FileStuctures,DataTypeList,PlotDataTypes,cd_init,debugON,cd_load);
    otherwise
        disp('You have decided not to find the mean value within a range...');
        % Setting DataIDName to nan will then make NanoDataSave ask for
        % DataIDName when it runs.
        DataIDName = '';
end

%% Saving Results

% Loading mode is true as we using the Loader function.
LoadingMode = true;
cd(cd_init);
% The output data is mainly useful for NanoDataCreater but not for this.
NanoPlotterFigureSaver(debugON,ImageFormatType,LoadingMode,cd_init,DataIDName,cd_load);


fprintf('%s: Completed!\n\n',dlg_title);

end











    
%% Functions

% The below helps keep track whether the user wants to change what the code
% saves the figures as in terms of file type.
function ImageFormatType = changeFigureSaveType
    % This sees if this variable already exists, which it should do if the
    % code has been ran before.
    if logical(exist('ImageFormatType','var')) == false
        % In the case where the format type variable does not exist, it
        % forces the user to choose one.
        ImageFormatType = ImageSaveType;
    else
        % The following occurs if a choice has been made before.
        % N.B. Ignore the below warning, this occurs when ImageFormatType
        % already exists.
        quest = sprintf('Change image saving filetype from ".%s"?:',ImageFormatType);
        
        % This is a user preference dialogue asking if they wish to change
        % what it saves the figures as.
        [ImageSavingRepYN,~] = uigetpref('Settings','ImageSaving',code_title,quest,{'Yes','No'},'DefaultButton','No');
        
        % If the user selects yes then it gives them the option to choose
        % what to save the figures as, otherwise it will use the
        % pre-existing variable value.
        if strcmp(ImageSavingRepYN,'yes')
            ImageFormatType = ImageSaveType;
        elseif strcmp(ImageSavingRepYN,'no')
             fprintf('"ImageFormatType" from before of "%s" will be used\n',ImageFormatType);
        end
    end
end

% This is used in changeFigureSaveType.
function ImageFormatType = ImageSaveType
    PromptString = {'Select image filetype for figures to save as:','Only one type can be selected at a time.'};
    imageTypeList = {'fig','m','tiffn','tiff','jpeg','png','pdf','svg','eps'};
    
    % List dialogue pop-up.
    [ImageFormatType,~] = listdlg('PromptString',PromptString,'SelectionMode','single','ListString',imageTypeList);
    
    % This changes ImageFormatType from being a number to the character
    % value in imageTypeList.
    ImageFormatType = imageTypeList{ImageFormatType};
end


% Following on from above, the if this check is not done then we are
% mixing data with different error analysis.
% The variable names is dependent on the method and machine, and this
% check is done because currently the code is limited with capability.
% May impliment an advanced plotter which the user has to select the
% column for a specific data type to plot.
function passTF = checkStructuresCompat(debugON,FileStuctures)
    NumLoaded = length(FileStuctures);

    if debugON == true
        fprintf('FileStuctures has length of %d...\n',NumLoaded);
    end
    
    w_check_array = nan(NumLoaded,1);
    stdevORstderror_check = cell(NumLoaded,1);
    
    varNames_all_same = true;
    
    first_varNames = FileStuctures{1}.varNames;
    
    for i = 1:NumLoaded
        current_struct = FileStuctures{i};
        current_w = current_struct.w;
        current_varNames = current_struct.varNames;
        stdevORstderror_check{i} = current_struct.ErrorPlotMode;
        w_check_array(i) = current_w;
%         fprintf('%s has w = %d...\n',current_struct.DataIDName,current_w);
        if strcmp(char(current_varNames),char(first_varNames)) == false
            varNames_all_same = false;
        end
    end
    
    w_all_same = ( length(unique(w_check_array)) == 1 );
    Std_all_same = ( length(unique(stdevORstderror_check)) == 1 );
    
    if (w_all_same == false) || (varNames_all_same == false) || (Std_all_same == false)
        Message = cell(3,1);
        Message{1} = sprintf('The files loaded have something not the same (i.e. "false"): \n');
        Message{2} = sprintf(' - standard deviation weighting (w) = %s \n', logical2String(w_all_same));
        Message{3} = sprintf(' - variable names (varNames) = %s \n', logical2String(varNames_all_same));
        Message{4} = sprintf(' - same error type (stdev or stderror) = %s \n', logical2String(Std_all_same));
        DLG = errordlg(Message);
        waitfor(DLG);
        passTF = false;
        return
    else
        passTF = true;
    end
    
end

function Output = logical2String(input)
    if input == true
        Output = "true";
    elseif input == false
        Output = "false";
    else
        Output = "Error!";
    end
end